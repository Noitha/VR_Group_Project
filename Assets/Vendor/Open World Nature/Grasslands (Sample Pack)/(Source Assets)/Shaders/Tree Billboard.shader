Shader "Universal Render Pipeline/Open World Nature/Tree Billboard"
{
    Properties
    {
        _AlphaClipThreshold("Alpha Clip ", Range(0, 1)) = 0.5
_Hue("Hue ", Range(-0.5, 0.5)) = 0
_Saturation("Saturation ", Range(-1, 1)) = 0
_Lightness("Lightness ", Range(-1, 1)) = 0
[NoScaleOffset] _Albedo("Albedo", 2D) = "white" {}
[NoScaleOffset] _BumpMap("Bump", 2D) = "bump" {}

    }
    SubShader
    {
        Tags
        {
            "RenderPipeline"="UniversalPipeline"
            "RenderType"="Opaque"
            "Queue"="Geometry+0"
        }
        Pass
        {
        	Tags{"LightMode" = "UniversalForward"}

        	// Material options generated by graph

            Blend One Zero, One Zero

            Cull Back

            ZTest LEqual

            ZWrite On

        	HLSLPROGRAM
            // Required to compile gles 2.0 with standard srp library
            #pragma prefer_hlslcc gles
            #pragma exclude_renderers d3d11_9x
            #pragma target 2.0

        	// -------------------------------------
            // Universal Pipeline keywords
            #pragma multi_compile _ _MAIN_LIGHT_SHADOWS
            #pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE
            #pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS
            #pragma multi_compile _ _ADDITIONAL_LIGHT_SHADOWS
            #pragma multi_compile _ _SHADOWS_SOFT
            #pragma multi_compile _ _MIXED_LIGHTING_SUBTRACTIVE
            
        	// -------------------------------------
            // Unity defined keywords
            #pragma multi_compile _ DIRLIGHTMAP_COMBINED
            #pragma multi_compile _ LIGHTMAP_ON
            #pragma multi_compile_fog

            //--------------------------------------
            // GPU Instancing
            #pragma multi_compile_instancing

            #pragma vertex vert
        	#pragma fragment frag

        	// Defines generated by graph
            #define _NORMALMAP 1
            #define _AlphaClip 1

        	#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
        	#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/UnityInstancing.hlsl"
        	#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl"

            CBUFFER_START(UnityPerMaterial)
            float _AlphaClipThreshold;
            float _Hue;
            float _Saturation;
            float _Lightness;
            CBUFFER_END

            TEXTURE2D(_Albedo); SAMPLER(sampler_Albedo); float4 _Albedo_TexelSize;
            TEXTURE2D(_BumpMap); SAMPLER(sampler_BumpMap); float4 _BumpMap_TexelSize;
            struct VertexDescriptionInputs
            {
                float3 WorldSpaceNormal;
                float3 WorldSpaceTangent;
                float3 WorldSpaceBiTangent;
                float3 ObjectSpacePosition;
            };

            struct SurfaceDescriptionInputs
            {
                float3 WorldSpaceNormal;
                float3 WorldSpaceTangent;
                float3 WorldSpaceBiTangent;
                half4 uv0;
            };


            void Unity_Subtract_float3(float3 A, float3 B, out float3 Out)
            {
                Out = A - B;
            }

            void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG)
            {
                RGBA = float4(R, G, B, A);
                RGB = float3(R, G, B);
                RG = float2(R, G);
            }

            void Unity_Normalize_float3(float3 In, out float3 Out)
            {
                Out = normalize(In);
            }

            void Unity_CrossProduct_float(float3 A, float3 B, out float3 Out)
            {
                Out = cross(A, B);
            }

            void Unity_Multiply_float (float3 A, float3 B, out float3 Out)
            {
                Out = A * B;
            }

            void Unity_Arctangent2_float(float A, float B, out float Out)
            {
                Out = atan2(A, B);
            }

            void Unity_RadiansToDegrees_float(float In, out float Out)
            {
                Out = degrees(In);
            }

            void Unity_Add_float(float A, float B, out float Out)
            {
                Out = A + B;
            }

            void Unity_Modulo_float(float A, float B, out float Out)
            {
                Out = fmod(A, B);
            }

            void Unity_Subtract_float(float A, float B, out float Out)
            {
                Out = A - B;
            }

            void Unity_Remap_float(float In, float2 InMinMax, float2 OutMinMax, out float Out)
            {
                Out = OutMinMax.x + (In - InMinMax.x) * (OutMinMax.y - OutMinMax.x) / (InMinMax.y - InMinMax.x);
            }

            void Unity_Floor_float(float In, out float Out)
            {
                Out = floor(In);
            }

            void Unity_Divide_float(float A, float B, out float Out)
            {
                Out = A / B;
            }

            void Unity_OneMinus_float(float In, out float Out)
            {
                Out = 1 - In;
            }

            void Unity_Multiply_float (float A, float B, out float Out)
            {
                Out = A * B;
            }

            void Unity_Divide_float4(float4 A, float4 B, out float4 Out)
            {
                Out = A / B;
            }

            void Unity_Add_float2(float2 A, float2 B, out float2 Out)
            {
                Out = A + B;
            }

            void Unity_Hue_Normalized_float(float3 In, float Offset, out float3 Out)
            {
                // RGB to HSV
                float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
                float4 P = lerp(float4(In.bg, K.wz), float4(In.gb, K.xy), step(In.b, In.g));
                float4 Q = lerp(float4(P.xyw, In.r), float4(In.r, P.yzx), step(P.x, In.r));
                float D = Q.x - min(Q.w, Q.y);
                float E = 1e-10;
                float3 hsv = float3(abs(Q.z + (Q.w - Q.y)/(6.0 * D + E)), D / (Q.x + E), Q.x);

                float hue = hsv.x + Offset;
                hsv.x = (hue < 0)
                        ? hue + 1
                        : (hue > 1)
                            ? hue - 1
                            : hue;

                // HSV to RGB
                float4 K2 = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                float3 P2 = abs(frac(hsv.xxx + K2.xyz) * 6.0 - K2.www);
                Out = hsv.z * lerp(K2.xxx, saturate(P2 - K2.xxx), hsv.y);
            }

            void Unity_Saturation_float(float3 In, float Saturation, out float3 Out)
            {
                float luma = dot(In, float3(0.2126729, 0.7151522, 0.0721750));
                Out =  luma.xxx + Saturation.xxx * (In - luma.xxx);
            }

            void Unity_Add_float3(float3 A, float3 B, out float3 Out)
            {
                Out = A + B;
            }

            struct VertexDescription
            {
                float3 Position;
            };

            VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
            {
                VertexDescription description = (VertexDescription)0;
                float _Split_FA827202_R_1 = IN.ObjectSpacePosition[0];
                float _Split_FA827202_G_2 = IN.ObjectSpacePosition[1];
                float _Split_FA827202_B_3 = IN.ObjectSpacePosition[2];
                float _Split_FA827202_A_4 = 0;
                float3 _Vector3_F70CD4C3_Out_0 = float3(_Split_FA827202_R_1, 0, _Split_FA827202_R_1);
                float3 _Subtract_74F98413_Out_2;
                Unity_Subtract_float3(SHADERGRAPH_OBJECT_POSITION, _WorldSpaceCameraPos, _Subtract_74F98413_Out_2);
                float _Split_67329DB8_R_1 = _Subtract_74F98413_Out_2[0];
                float _Split_67329DB8_G_2 = _Subtract_74F98413_Out_2[1];
                float _Split_67329DB8_B_3 = _Subtract_74F98413_Out_2[2];
                float _Split_67329DB8_A_4 = 0;
                float4 _Combine_F209DAD0_RGBA_4;
                float3 _Combine_F209DAD0_RGB_5;
                float2 _Combine_F209DAD0_RG_6;
                Unity_Combine_float(_Split_67329DB8_R_1, 0, _Split_67329DB8_B_3, 0, _Combine_F209DAD0_RGBA_4, _Combine_F209DAD0_RGB_5, _Combine_F209DAD0_RG_6);
                float3 _Normalize_1F9A769D_Out_1;
                Unity_Normalize_float3(_Combine_F209DAD0_RGB_5, _Normalize_1F9A769D_Out_1);
                float3 _Transform_C904C633_Out_1 = TransformWorldToObjectDir(_Normalize_1F9A769D_Out_1.xyz);
                float3 _Vector3_3F5F1FB6_Out_0 = float3(0, 1, 0);
                float3 _CrossProduct_ECD4E36B_Out_2;
                Unity_CrossProduct_float(_Transform_C904C633_Out_1, _Vector3_3F5F1FB6_Out_0, _CrossProduct_ECD4E36B_Out_2);
                float3 _Multiply_6B52A67B_Out_2;
                Unity_Multiply_float(_CrossProduct_ECD4E36B_Out_2, float3(-1, -1, -1), _Multiply_6B52A67B_Out_2);
                float3 _Multiply_95A81659_Out_2;
                Unity_Multiply_float(_Vector3_F70CD4C3_Out_0, _Multiply_6B52A67B_Out_2, _Multiply_95A81659_Out_2);
                float _Split_1A54F8B_R_1 = _Multiply_95A81659_Out_2[0];
                float _Split_1A54F8B_G_2 = _Multiply_95A81659_Out_2[1];
                float _Split_1A54F8B_B_3 = _Multiply_95A81659_Out_2[2];
                float _Split_1A54F8B_A_4 = 0;
                float4 _Combine_F763F954_RGBA_4;
                float3 _Combine_F763F954_RGB_5;
                float2 _Combine_F763F954_RG_6;
                Unity_Combine_float(_Split_1A54F8B_R_1, _Split_FA827202_G_2, _Split_1A54F8B_B_3, 0, _Combine_F763F954_RGBA_4, _Combine_F763F954_RGB_5, _Combine_F763F954_RG_6);
                description.Position = _Combine_F763F954_RGB_5;
                return description;
            }

            struct SurfaceDescription
            {
                float3 Albedo;
                float3 Normal;
                float3 Emission;
                float Metallic;
                float Smoothness;
                float Occlusion;
                float Alpha;
                float AlphaClipThreshold;
            };

            SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
            {
                SurfaceDescription surface = (SurfaceDescription)0;
                float3 _Subtract_74F98413_Out_2;
                Unity_Subtract_float3(SHADERGRAPH_OBJECT_POSITION, _WorldSpaceCameraPos, _Subtract_74F98413_Out_2);
                float _Split_67329DB8_R_1 = _Subtract_74F98413_Out_2[0];
                float _Split_67329DB8_G_2 = _Subtract_74F98413_Out_2[1];
                float _Split_67329DB8_B_3 = _Subtract_74F98413_Out_2[2];
                float _Split_67329DB8_A_4 = 0;
                float4 _Combine_F209DAD0_RGBA_4;
                float3 _Combine_F209DAD0_RGB_5;
                float2 _Combine_F209DAD0_RG_6;
                Unity_Combine_float(_Split_67329DB8_R_1, 0, _Split_67329DB8_B_3, 0, _Combine_F209DAD0_RGBA_4, _Combine_F209DAD0_RGB_5, _Combine_F209DAD0_RG_6);
                float3 _Normalize_1F9A769D_Out_1;
                Unity_Normalize_float3(_Combine_F209DAD0_RGB_5, _Normalize_1F9A769D_Out_1);
                float3 _Transform_C904C633_Out_1 = TransformWorldToObjectDir(_Normalize_1F9A769D_Out_1.xyz);
                float _Split_ADCD8D4F_R_1 = _Transform_C904C633_Out_1[0];
                float _Split_ADCD8D4F_G_2 = _Transform_C904C633_Out_1[1];
                float _Split_ADCD8D4F_B_3 = _Transform_C904C633_Out_1[2];
                float _Split_ADCD8D4F_A_4 = 0;
                float _Arctangent2_4039E87E_Out_2;
                Unity_Arctangent2_float(_Split_ADCD8D4F_B_3, _Split_ADCD8D4F_R_1, _Arctangent2_4039E87E_Out_2);
                float _RadiansToDegrees_822E9378_Out_1;
                Unity_RadiansToDegrees_float(_Arctangent2_4039E87E_Out_2, _RadiansToDegrees_822E9378_Out_1);
                float _Add_F423FB93_Out_2;
                Unity_Add_float(_RadiansToDegrees_822E9378_Out_1, 0, _Add_F423FB93_Out_2);
                float _Add_B5DF3C81_Out_2;
                Unity_Add_float(_Add_F423FB93_Out_2, 90, _Add_B5DF3C81_Out_2);
                float _Modulo_E642AF79_Out_2;
                Unity_Modulo_float(_Add_B5DF3C81_Out_2, 360, _Modulo_E642AF79_Out_2);
                float _Subtract_420DDE08_Out_2;
                Unity_Subtract_float(360, _Modulo_E642AF79_Out_2, _Subtract_420DDE08_Out_2);
                float _Remap_859F7A9D_Out_3;
                Unity_Remap_float(_Subtract_420DDE08_Out_2, float2 (0, 360), float2 (0, 16), _Remap_859F7A9D_Out_3);
                float _Floor_AE29D009_Out_1;
                Unity_Floor_float(_Remap_859F7A9D_Out_3, _Floor_AE29D009_Out_1);
                float _Divide_EC99B270_Out_2;
                Unity_Divide_float(_Floor_AE29D009_Out_1, 4, _Divide_EC99B270_Out_2);
                float _Floor_BECE6315_Out_1;
                Unity_Floor_float(_Divide_EC99B270_Out_2, _Floor_BECE6315_Out_1);
                float _Divide_5696F1A6_Out_2;
                Unity_Divide_float(_Floor_BECE6315_Out_1, 4, _Divide_5696F1A6_Out_2);
                float _OneMinus_3DBE3279_Out_1;
                Unity_OneMinus_float(_Divide_5696F1A6_Out_2, _OneMinus_3DBE3279_Out_1);
                float _Multiply_D3C5014D_Out_2;
                Unity_Multiply_float(_Floor_BECE6315_Out_1, 4, _Multiply_D3C5014D_Out_2);
                float _Subtract_1796B96F_Out_2;
                Unity_Subtract_float(_Floor_AE29D009_Out_1, _Multiply_D3C5014D_Out_2, _Subtract_1796B96F_Out_2);
                float _Divide_F6C8A2F_Out_2;
                Unity_Divide_float(_Subtract_1796B96F_Out_2, 4, _Divide_F6C8A2F_Out_2);
                float2 _Vector2_7D220493_Out_0 = float2(_OneMinus_3DBE3279_Out_1, _Divide_F6C8A2F_Out_2);
                float4 _UV_76C93B5D_Out_0 = IN.uv0;
                float4 _Divide_9FCFC3DD_Out_2;
                Unity_Divide_float4(_UV_76C93B5D_Out_0, float4(4, 4, 4, 4), _Divide_9FCFC3DD_Out_2);
                float2 _Add_C3699259_Out_2;
                Unity_Add_float2(_Vector2_7D220493_Out_0, (_Divide_9FCFC3DD_Out_2.xy), _Add_C3699259_Out_2);
                float4 _SampleTexture2D_29A29D61_RGBA_0 = SAMPLE_TEXTURE2D(_Albedo, sampler_Albedo, _Add_C3699259_Out_2);
                float _SampleTexture2D_29A29D61_R_4 = _SampleTexture2D_29A29D61_RGBA_0.r;
                float _SampleTexture2D_29A29D61_G_5 = _SampleTexture2D_29A29D61_RGBA_0.g;
                float _SampleTexture2D_29A29D61_B_6 = _SampleTexture2D_29A29D61_RGBA_0.b;
                float _SampleTexture2D_29A29D61_A_7 = _SampleTexture2D_29A29D61_RGBA_0.a;
                float _Property_A51D11B2_Out_0 = _Hue;
                float3 _Hue_D09989EF_Out_2;
                Unity_Hue_Normalized_float((_SampleTexture2D_29A29D61_RGBA_0.xyz), _Property_A51D11B2_Out_0, _Hue_D09989EF_Out_2);
                float _Property_3C770CFC_Out_0 = _Saturation;
                float _Add_515FA5ED_Out_2;
                Unity_Add_float(_Property_3C770CFC_Out_0, 1, _Add_515FA5ED_Out_2);
                float3 _Saturation_843CD1F5_Out_2;
                Unity_Saturation_float(_Hue_D09989EF_Out_2, _Add_515FA5ED_Out_2, _Saturation_843CD1F5_Out_2);
                float _Property_93DBCFB9_Out_0 = _Lightness;
                float3 _Add_52C2111C_Out_2;
                Unity_Add_float3(_Saturation_843CD1F5_Out_2, (_Property_93DBCFB9_Out_0.xxx), _Add_52C2111C_Out_2);
                float4 _SampleTexture2D_E4B29158_RGBA_0 = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap, _Add_C3699259_Out_2);
                _SampleTexture2D_E4B29158_RGBA_0.rgb = UnpackNormalmapRGorAG(_SampleTexture2D_E4B29158_RGBA_0);
                float _SampleTexture2D_E4B29158_R_4 = _SampleTexture2D_E4B29158_RGBA_0.r;
                float _SampleTexture2D_E4B29158_G_5 = _SampleTexture2D_E4B29158_RGBA_0.g;
                float _SampleTexture2D_E4B29158_B_6 = _SampleTexture2D_E4B29158_RGBA_0.b;
                float _SampleTexture2D_E4B29158_A_7 = _SampleTexture2D_E4B29158_RGBA_0.a;
                float _Property_DA5F57E_Out_0 = _AlphaClipThreshold;
                surface.Albedo = _Add_52C2111C_Out_2;
                surface.Normal = (_SampleTexture2D_E4B29158_RGBA_0.xyz);
                surface.Emission = IsGammaSpace() ? float3(0, 0, 0) : SRGBToLinear(float3(0, 0, 0));
                surface.Metallic = 0;
                surface.Smoothness = 0.15;
                surface.Occlusion = 1;
                surface.Alpha = _SampleTexture2D_29A29D61_A_7;
                surface.AlphaClipThreshold = _Property_DA5F57E_Out_0;
                return surface;
            }

            struct GraphVertexInput
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 tangent : TANGENT;
                float4 texcoord0 : TEXCOORD0;
                float4 texcoord1 : TEXCOORD1;
                UNITY_VERTEX_INPUT_INSTANCE_ID
            };


        	struct GraphVertexOutput
            {
                float4 clipPos                : SV_POSITION;
                DECLARE_LIGHTMAP_OR_SH(lightmapUV, vertexSH, 0);
        		half4 fogFactorAndVertexLight : TEXCOORD1; // x: fogFactor, yzw: vertex light
            	float4 shadowCoord            : TEXCOORD2;

        		// Interpolators defined by graph
                float3 WorldSpacePosition : TEXCOORD3;
                float3 WorldSpaceNormal : TEXCOORD4;
                float3 WorldSpaceTangent : TEXCOORD5;
                float3 WorldSpaceBiTangent : TEXCOORD6;
                float3 WorldSpaceViewDirection : TEXCOORD7;
                half4 uv0 : TEXCOORD8;
                half4 uv1 : TEXCOORD9;

                UNITY_VERTEX_INPUT_INSTANCE_ID
            	UNITY_VERTEX_OUTPUT_STEREO
            };

            GraphVertexOutput vert (GraphVertexInput v)
        	{
        		GraphVertexOutput o = (GraphVertexOutput)0;
                UNITY_SETUP_INSTANCE_ID(v);
            	UNITY_TRANSFER_INSTANCE_ID(v, o);
        		UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

        		// Vertex transformations performed by graph
                float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
                float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
                float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
                float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
                float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
                float4 uv0 = v.texcoord0;
                float4 uv1 = v.texcoord1;
                float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;

        		VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

        		// Vertex description inputs defined by graph
                vdi.WorldSpaceNormal = WorldSpaceNormal;
                vdi.WorldSpaceTangent = WorldSpaceTangent;
                vdi.WorldSpaceBiTangent = WorldSpaceBiTangent;
                vdi.ObjectSpacePosition = ObjectSpacePosition;

        	    VertexDescription vd = PopulateVertexData(vdi);
        		v.vertex.xyz = vd.Position;

        		// Vertex shader outputs defined by graph
                o.WorldSpacePosition = WorldSpacePosition;
                o.WorldSpaceNormal = WorldSpaceNormal;
                o.WorldSpaceTangent = WorldSpaceTangent;
                o.WorldSpaceBiTangent = WorldSpaceBiTangent;
                o.WorldSpaceViewDirection = WorldSpaceViewDirection;
                o.uv0 = uv0;
                o.uv1 = uv1;

        		float3 lwWNormal = TransformObjectToWorldNormal(v.normal);

                VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);
                
         		// We either sample GI from lightmap or SH.
        	    // Lightmap UV and vertex SH coefficients use the same interpolator ("float2 lightmapUV" for lightmap or "half3 vertexSH" for SH)
                // see DECLARE_LIGHTMAP_OR_SH macro.
        	    // The following funcions initialize the correct variable with correct data
        	    OUTPUT_LIGHTMAP_UV(v.texcoord1, unity_LightmapST, o.lightmapUV);
        	    OUTPUT_SH(lwWNormal, o.vertexSH);

        	    half3 vertexLight = VertexLighting(vertexInput.positionWS, lwWNormal);
        	    half fogFactor = ComputeFogFactor(vertexInput.positionCS.z);
        	    o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);
        	    o.clipPos = vertexInput.positionCS;

        	#ifdef _MAIN_LIGHT_SHADOWS
        		o.shadowCoord = GetShadowCoord(vertexInput);
        	#endif
        		return o;
        	}

        	half4 frag (GraphVertexOutput IN ) : SV_Target
            {
            	UNITY_SETUP_INSTANCE_ID(IN);
        		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);

        		// Pixel transformations performed by graph
                float3 WorldSpacePosition = IN.WorldSpacePosition;
                float3 WorldSpaceNormal = IN.WorldSpaceNormal;
                float3 WorldSpaceTangent = IN.WorldSpaceTangent;
                float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
                float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
                float4 uv0 = IN.uv0;
                float4 uv1 = IN.uv1;

                SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

        		// Surface description inputs defined by graph
                surfaceInput.WorldSpaceNormal = WorldSpaceNormal;
                surfaceInput.WorldSpaceTangent = WorldSpaceTangent;
                surfaceInput.WorldSpaceBiTangent = WorldSpaceBiTangent;
                surfaceInput.uv0 = uv0;

                SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

        		float3 Albedo = float3(0.5, 0.5, 0.5);
        		float3 Specular = float3(0, 0, 0);
        		float Metallic = 1;
        		float3 Normal = float3(0, 0, 1);
        		float3 Emission = 0;
        		float Smoothness = 0.5;
        		float Occlusion = 1;
        		float Alpha = 1;
        		float AlphaClipThreshold = 0;

        		// Surface description remap performed by graph
                Albedo = surf.Albedo;
                Normal = surf.Normal;
                Emission = surf.Emission;
                Metallic = surf.Metallic;
                Smoothness = surf.Smoothness;
                Occlusion = surf.Occlusion;
                Alpha = surf.Alpha;
                AlphaClipThreshold = surf.AlphaClipThreshold;

        		InputData inputData;
        		inputData.positionWS = WorldSpacePosition;

        #ifdef _NORMALMAP
        	    inputData.normalWS = normalize(TransformTangentToWorld(Normal, half3x3(WorldSpaceTangent, WorldSpaceBiTangent, WorldSpaceNormal)));
        #else
            #if !SHADER_HINT_NICE_QUALITY
                inputData.normalWS = WorldSpaceNormal;
            #else
        	    inputData.normalWS = normalize(WorldSpaceNormal);
            #endif
        #endif

        #if !SHADER_HINT_NICE_QUALITY
        	    // viewDirection should be normalized here, but we avoid doing it as it's close enough and we save some ALU.
        	    inputData.viewDirectionWS = WorldSpaceViewDirection;
        #else
        	    inputData.viewDirectionWS = normalize(WorldSpaceViewDirection);
        #endif

        	    inputData.shadowCoord = IN.shadowCoord;

        	    inputData.fogCoord = IN.fogFactorAndVertexLight.x;
        	    inputData.vertexLighting = IN.fogFactorAndVertexLight.yzw;
        	    inputData.bakedGI = SAMPLE_GI(IN.lightmapUV, IN.vertexSH, inputData.normalWS);

        		half4 color = UniversalFragmentPBR(
        			inputData, 
        			Albedo, 
        			Metallic, 
        			Specular, 
        			Smoothness, 
        			Occlusion, 
        			Emission, 
        			Alpha);

        		// Computes fog factor per-vertex
            	color.rgb = MixFog(color.rgb, IN.fogFactorAndVertexLight.x);

        #if _AlphaClip
        		clip(Alpha - AlphaClipThreshold);
        #endif
        		return color;
            }

        	ENDHLSL
        }
        Pass
        {
        	Name "ShadowCaster"
            Tags{"LightMode" = "ShadowCaster"}

            ZWrite On ZTest LEqual

            // Material options generated by graph
            Cull Back

            HLSLPROGRAM
            // Required to compile gles 2.0 with standard srp library
            #pragma prefer_hlslcc gles
            #pragma exclude_renderers d3d11_9x
            #pragma target 2.0

            //--------------------------------------
            // GPU Instancing
            #pragma multi_compile_instancing

            #pragma vertex ShadowPassVertex
            #pragma fragment ShadowPassFragment

            // Defines generated by graph
            #define _NORMALMAP 1
            #define _AlphaClip 1

            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"

            CBUFFER_START(UnityPerMaterial)
            float _AlphaClipThreshold;
            float _Hue;
            float _Saturation;
            float _Lightness;
            CBUFFER_END

            TEXTURE2D(_Albedo); SAMPLER(sampler_Albedo); float4 _Albedo_TexelSize;
            TEXTURE2D(_BumpMap); SAMPLER(sampler_BumpMap); float4 _BumpMap_TexelSize;
            struct VertexDescriptionInputs
            {
                float3 WorldSpaceNormal;
                float3 WorldSpaceTangent;
                float3 WorldSpaceBiTangent;
                float3 ObjectSpacePosition;
            };

            struct SurfaceDescriptionInputs
            {
                float3 WorldSpaceNormal;
                float3 WorldSpaceTangent;
                float3 WorldSpaceBiTangent;
                half4 uv0;
            };


            void Unity_Subtract_float3(float3 A, float3 B, out float3 Out)
            {
                Out = A - B;
            }

            void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG)
            {
                RGBA = float4(R, G, B, A);
                RGB = float3(R, G, B);
                RG = float2(R, G);
            }

            void Unity_Normalize_float3(float3 In, out float3 Out)
            {
                Out = normalize(In);
            }

            void Unity_CrossProduct_float(float3 A, float3 B, out float3 Out)
            {
                Out = cross(A, B);
            }

            void Unity_Multiply_float (float3 A, float3 B, out float3 Out)
            {
                Out = A * B;
            }

            void Unity_Arctangent2_float(float A, float B, out float Out)
            {
                Out = atan2(A, B);
            }

            void Unity_RadiansToDegrees_float(float In, out float Out)
            {
                Out = degrees(In);
            }

            void Unity_Add_float(float A, float B, out float Out)
            {
                Out = A + B;
            }

            void Unity_Modulo_float(float A, float B, out float Out)
            {
                Out = fmod(A, B);
            }

            void Unity_Subtract_float(float A, float B, out float Out)
            {
                Out = A - B;
            }

            void Unity_Remap_float(float In, float2 InMinMax, float2 OutMinMax, out float Out)
            {
                Out = OutMinMax.x + (In - InMinMax.x) * (OutMinMax.y - OutMinMax.x) / (InMinMax.y - InMinMax.x);
            }

            void Unity_Floor_float(float In, out float Out)
            {
                Out = floor(In);
            }

            void Unity_Divide_float(float A, float B, out float Out)
            {
                Out = A / B;
            }

            void Unity_OneMinus_float(float In, out float Out)
            {
                Out = 1 - In;
            }

            void Unity_Multiply_float (float A, float B, out float Out)
            {
                Out = A * B;
            }

            void Unity_Divide_float4(float4 A, float4 B, out float4 Out)
            {
                Out = A / B;
            }

            void Unity_Add_float2(float2 A, float2 B, out float2 Out)
            {
                Out = A + B;
            }

            void Unity_Hue_Normalized_float(float3 In, float Offset, out float3 Out)
            {
                // RGB to HSV
                float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
                float4 P = lerp(float4(In.bg, K.wz), float4(In.gb, K.xy), step(In.b, In.g));
                float4 Q = lerp(float4(P.xyw, In.r), float4(In.r, P.yzx), step(P.x, In.r));
                float D = Q.x - min(Q.w, Q.y);
                float E = 1e-10;
                float3 hsv = float3(abs(Q.z + (Q.w - Q.y)/(6.0 * D + E)), D / (Q.x + E), Q.x);

                float hue = hsv.x + Offset;
                hsv.x = (hue < 0)
                        ? hue + 1
                        : (hue > 1)
                            ? hue - 1
                            : hue;

                // HSV to RGB
                float4 K2 = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                float3 P2 = abs(frac(hsv.xxx + K2.xyz) * 6.0 - K2.www);
                Out = hsv.z * lerp(K2.xxx, saturate(P2 - K2.xxx), hsv.y);
            }

            void Unity_Saturation_float(float3 In, float Saturation, out float3 Out)
            {
                float luma = dot(In, float3(0.2126729, 0.7151522, 0.0721750));
                Out =  luma.xxx + Saturation.xxx * (In - luma.xxx);
            }

            void Unity_Add_float3(float3 A, float3 B, out float3 Out)
            {
                Out = A + B;
            }

            struct VertexDescription
            {
                float3 Position;
            };

            VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
            {
                VertexDescription description = (VertexDescription)0;
                float _Split_FA827202_R_1 = IN.ObjectSpacePosition[0];
                float _Split_FA827202_G_2 = IN.ObjectSpacePosition[1];
                float _Split_FA827202_B_3 = IN.ObjectSpacePosition[2];
                float _Split_FA827202_A_4 = 0;
                float3 _Vector3_F70CD4C3_Out_0 = float3(_Split_FA827202_R_1, 0, _Split_FA827202_R_1);
                float3 _Subtract_74F98413_Out_2;
                Unity_Subtract_float3(SHADERGRAPH_OBJECT_POSITION, _WorldSpaceCameraPos, _Subtract_74F98413_Out_2);
                float _Split_67329DB8_R_1 = _Subtract_74F98413_Out_2[0];
                float _Split_67329DB8_G_2 = _Subtract_74F98413_Out_2[1];
                float _Split_67329DB8_B_3 = _Subtract_74F98413_Out_2[2];
                float _Split_67329DB8_A_4 = 0;
                float4 _Combine_F209DAD0_RGBA_4;
                float3 _Combine_F209DAD0_RGB_5;
                float2 _Combine_F209DAD0_RG_6;
                Unity_Combine_float(_Split_67329DB8_R_1, 0, _Split_67329DB8_B_3, 0, _Combine_F209DAD0_RGBA_4, _Combine_F209DAD0_RGB_5, _Combine_F209DAD0_RG_6);
                float3 _Normalize_1F9A769D_Out_1;
                Unity_Normalize_float3(_Combine_F209DAD0_RGB_5, _Normalize_1F9A769D_Out_1);
                float3 _Transform_C904C633_Out_1 = TransformWorldToObjectDir(_Normalize_1F9A769D_Out_1.xyz);
                float3 _Vector3_3F5F1FB6_Out_0 = float3(0, 1, 0);
                float3 _CrossProduct_ECD4E36B_Out_2;
                Unity_CrossProduct_float(_Transform_C904C633_Out_1, _Vector3_3F5F1FB6_Out_0, _CrossProduct_ECD4E36B_Out_2);
                float3 _Multiply_6B52A67B_Out_2;
                Unity_Multiply_float(_CrossProduct_ECD4E36B_Out_2, float3(-1, -1, -1), _Multiply_6B52A67B_Out_2);
                float3 _Multiply_95A81659_Out_2;
                Unity_Multiply_float(_Vector3_F70CD4C3_Out_0, _Multiply_6B52A67B_Out_2, _Multiply_95A81659_Out_2);
                float _Split_1A54F8B_R_1 = _Multiply_95A81659_Out_2[0];
                float _Split_1A54F8B_G_2 = _Multiply_95A81659_Out_2[1];
                float _Split_1A54F8B_B_3 = _Multiply_95A81659_Out_2[2];
                float _Split_1A54F8B_A_4 = 0;
                float4 _Combine_F763F954_RGBA_4;
                float3 _Combine_F763F954_RGB_5;
                float2 _Combine_F763F954_RG_6;
                Unity_Combine_float(_Split_1A54F8B_R_1, _Split_FA827202_G_2, _Split_1A54F8B_B_3, 0, _Combine_F763F954_RGBA_4, _Combine_F763F954_RGB_5, _Combine_F763F954_RG_6);
                description.Position = _Combine_F763F954_RGB_5;
                return description;
            }

            struct SurfaceDescription
            {
                float3 Albedo;
                float3 Emission;
                float Alpha;
                float AlphaClipThreshold;
            };

            SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
            {
                SurfaceDescription surface = (SurfaceDescription)0;
                float3 _Subtract_74F98413_Out_2;
                Unity_Subtract_float3(SHADERGRAPH_OBJECT_POSITION, _WorldSpaceCameraPos, _Subtract_74F98413_Out_2);
                float _Split_67329DB8_R_1 = _Subtract_74F98413_Out_2[0];
                float _Split_67329DB8_G_2 = _Subtract_74F98413_Out_2[1];
                float _Split_67329DB8_B_3 = _Subtract_74F98413_Out_2[2];
                float _Split_67329DB8_A_4 = 0;
                float4 _Combine_F209DAD0_RGBA_4;
                float3 _Combine_F209DAD0_RGB_5;
                float2 _Combine_F209DAD0_RG_6;
                Unity_Combine_float(_Split_67329DB8_R_1, 0, _Split_67329DB8_B_3, 0, _Combine_F209DAD0_RGBA_4, _Combine_F209DAD0_RGB_5, _Combine_F209DAD0_RG_6);
                float3 _Normalize_1F9A769D_Out_1;
                Unity_Normalize_float3(_Combine_F209DAD0_RGB_5, _Normalize_1F9A769D_Out_1);
                float3 _Transform_C904C633_Out_1 = TransformWorldToObjectDir(_Normalize_1F9A769D_Out_1.xyz);
                float _Split_ADCD8D4F_R_1 = _Transform_C904C633_Out_1[0];
                float _Split_ADCD8D4F_G_2 = _Transform_C904C633_Out_1[1];
                float _Split_ADCD8D4F_B_3 = _Transform_C904C633_Out_1[2];
                float _Split_ADCD8D4F_A_4 = 0;
                float _Arctangent2_4039E87E_Out_2;
                Unity_Arctangent2_float(_Split_ADCD8D4F_B_3, _Split_ADCD8D4F_R_1, _Arctangent2_4039E87E_Out_2);
                float _RadiansToDegrees_822E9378_Out_1;
                Unity_RadiansToDegrees_float(_Arctangent2_4039E87E_Out_2, _RadiansToDegrees_822E9378_Out_1);
                float _Add_F423FB93_Out_2;
                Unity_Add_float(_RadiansToDegrees_822E9378_Out_1, 0, _Add_F423FB93_Out_2);
                float _Add_B5DF3C81_Out_2;
                Unity_Add_float(_Add_F423FB93_Out_2, 90, _Add_B5DF3C81_Out_2);
                float _Modulo_E642AF79_Out_2;
                Unity_Modulo_float(_Add_B5DF3C81_Out_2, 360, _Modulo_E642AF79_Out_2);
                float _Subtract_420DDE08_Out_2;
                Unity_Subtract_float(360, _Modulo_E642AF79_Out_2, _Subtract_420DDE08_Out_2);
                float _Remap_859F7A9D_Out_3;
                Unity_Remap_float(_Subtract_420DDE08_Out_2, float2 (0, 360), float2 (0, 16), _Remap_859F7A9D_Out_3);
                float _Floor_AE29D009_Out_1;
                Unity_Floor_float(_Remap_859F7A9D_Out_3, _Floor_AE29D009_Out_1);
                float _Divide_EC99B270_Out_2;
                Unity_Divide_float(_Floor_AE29D009_Out_1, 4, _Divide_EC99B270_Out_2);
                float _Floor_BECE6315_Out_1;
                Unity_Floor_float(_Divide_EC99B270_Out_2, _Floor_BECE6315_Out_1);
                float _Divide_5696F1A6_Out_2;
                Unity_Divide_float(_Floor_BECE6315_Out_1, 4, _Divide_5696F1A6_Out_2);
                float _OneMinus_3DBE3279_Out_1;
                Unity_OneMinus_float(_Divide_5696F1A6_Out_2, _OneMinus_3DBE3279_Out_1);
                float _Multiply_D3C5014D_Out_2;
                Unity_Multiply_float(_Floor_BECE6315_Out_1, 4, _Multiply_D3C5014D_Out_2);
                float _Subtract_1796B96F_Out_2;
                Unity_Subtract_float(_Floor_AE29D009_Out_1, _Multiply_D3C5014D_Out_2, _Subtract_1796B96F_Out_2);
                float _Divide_F6C8A2F_Out_2;
                Unity_Divide_float(_Subtract_1796B96F_Out_2, 4, _Divide_F6C8A2F_Out_2);
                float2 _Vector2_7D220493_Out_0 = float2(_OneMinus_3DBE3279_Out_1, _Divide_F6C8A2F_Out_2);
                float4 _UV_76C93B5D_Out_0 = IN.uv0;
                float4 _Divide_9FCFC3DD_Out_2;
                Unity_Divide_float4(_UV_76C93B5D_Out_0, float4(4, 4, 4, 4), _Divide_9FCFC3DD_Out_2);
                float2 _Add_C3699259_Out_2;
                Unity_Add_float2(_Vector2_7D220493_Out_0, (_Divide_9FCFC3DD_Out_2.xy), _Add_C3699259_Out_2);
                float4 _SampleTexture2D_29A29D61_RGBA_0 = SAMPLE_TEXTURE2D(_Albedo, sampler_Albedo, _Add_C3699259_Out_2);
                float _SampleTexture2D_29A29D61_R_4 = _SampleTexture2D_29A29D61_RGBA_0.r;
                float _SampleTexture2D_29A29D61_G_5 = _SampleTexture2D_29A29D61_RGBA_0.g;
                float _SampleTexture2D_29A29D61_B_6 = _SampleTexture2D_29A29D61_RGBA_0.b;
                float _SampleTexture2D_29A29D61_A_7 = _SampleTexture2D_29A29D61_RGBA_0.a;
                float _Property_A51D11B2_Out_0 = _Hue;
                float3 _Hue_D09989EF_Out_2;
                Unity_Hue_Normalized_float((_SampleTexture2D_29A29D61_RGBA_0.xyz), _Property_A51D11B2_Out_0, _Hue_D09989EF_Out_2);
                float _Property_3C770CFC_Out_0 = _Saturation;
                float _Add_515FA5ED_Out_2;
                Unity_Add_float(_Property_3C770CFC_Out_0, 1, _Add_515FA5ED_Out_2);
                float3 _Saturation_843CD1F5_Out_2;
                Unity_Saturation_float(_Hue_D09989EF_Out_2, _Add_515FA5ED_Out_2, _Saturation_843CD1F5_Out_2);
                float _Property_93DBCFB9_Out_0 = _Lightness;
                float3 _Add_52C2111C_Out_2;
                Unity_Add_float3(_Saturation_843CD1F5_Out_2, (_Property_93DBCFB9_Out_0.xxx), _Add_52C2111C_Out_2);
                float _Property_DA5F57E_Out_0 = _AlphaClipThreshold;
                surface.Albedo = _Add_52C2111C_Out_2;
                surface.Emission = IsGammaSpace() ? float3(0, 0, 0) : SRGBToLinear(float3(0, 0, 0));
                surface.Alpha = _SampleTexture2D_29A29D61_A_7;
                surface.AlphaClipThreshold = _Property_DA5F57E_Out_0;
                return surface;
            }

            struct GraphVertexInput
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 tangent : TANGENT;
                float4 texcoord0 : TEXCOORD0;
                float4 texcoord1 : TEXCOORD1;
                UNITY_VERTEX_INPUT_INSTANCE_ID
            };


        	struct VertexOutput
        	{
        	    float2 uv           : TEXCOORD0;
        	    float4 clipPos      : SV_POSITION;
                // Interpolators defined by graph
                float3 WorldSpacePosition : TEXCOORD3;
                float3 WorldSpaceNormal : TEXCOORD4;
                float3 WorldSpaceTangent : TEXCOORD5;
                float3 WorldSpaceBiTangent : TEXCOORD6;
                float3 WorldSpaceViewDirection : TEXCOORD7;
                half4 uv0 : TEXCOORD8;
                half4 uv1 : TEXCOORD9;

                UNITY_VERTEX_INPUT_INSTANCE_ID
        	};

            float3 _LightDirection;

            VertexOutput ShadowPassVertex(GraphVertexInput v)
        	{
        	    VertexOutput o;
        	    UNITY_SETUP_INSTANCE_ID(v);
                UNITY_TRANSFER_INSTANCE_ID(v, o);

                // Vertex transformations performed by graph
                float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
                float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
                float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
                float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
                float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
                float4 uv0 = v.texcoord0;
                float4 uv1 = v.texcoord1;
                float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;

        		VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

                // Vertex description inputs defined by graph
                vdi.WorldSpaceNormal = WorldSpaceNormal;
                vdi.WorldSpaceTangent = WorldSpaceTangent;
                vdi.WorldSpaceBiTangent = WorldSpaceBiTangent;
                vdi.ObjectSpacePosition = ObjectSpacePosition;

        	    VertexDescription vd = PopulateVertexData(vdi);
                v.vertex.xyz = vd.Position;

        	    // Vertex shader outputs defined by graph
                o.WorldSpacePosition = WorldSpacePosition;
                o.WorldSpaceNormal = WorldSpaceNormal;
                o.WorldSpaceTangent = WorldSpaceTangent;
                o.WorldSpaceBiTangent = WorldSpaceBiTangent;
                o.WorldSpaceViewDirection = WorldSpaceViewDirection;
                o.uv0 = uv0;
                o.uv1 = uv1;

        	    
        	    float3 positionWS = TransformObjectToWorld(v.vertex.xyz);
                float3 normalWS = TransformObjectToWorldNormal(v.normal);

                float4 clipPos = TransformWorldToHClip(ApplyShadowBias(positionWS, normalWS, _LightDirection));

        	#if UNITY_REVERSED_Z
        	    clipPos.z = min(clipPos.z, clipPos.w * UNITY_NEAR_CLIP_VALUE);
        	#else
        	    clipPos.z = max(clipPos.z, clipPos.w * UNITY_NEAR_CLIP_VALUE);
        	#endif
                o.clipPos = clipPos;

        	    return o;
        	}

            half4 ShadowPassFragment(VertexOutput IN ) : SV_TARGET
            {
                UNITY_SETUP_INSTANCE_ID(IN);

                // Pixel transformations performed by graph
                float3 WorldSpacePosition = IN.WorldSpacePosition;
                float3 WorldSpaceNormal = IN.WorldSpaceNormal;
                float3 WorldSpaceTangent = IN.WorldSpaceTangent;
                float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
                float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
                float4 uv0 = IN.uv0;
                float4 uv1 = IN.uv1;

                SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

        		// Surface description inputs defined by graph
                surfaceInput.WorldSpaceNormal = WorldSpaceNormal;
                surfaceInput.WorldSpaceTangent = WorldSpaceTangent;
                surfaceInput.WorldSpaceBiTangent = WorldSpaceBiTangent;
                surfaceInput.uv0 = uv0;

                SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

                float3 Albedo = float3(0.5, 0.5, 0.5);
        		float3 Emission = 0;
        		float Alpha = 1;
        		float AlphaClipThreshold = 0;

        		// Surface description remap performed by graph
                Albedo = surf.Albedo;
                Emission = surf.Emission;
                Alpha = surf.Alpha;
                AlphaClipThreshold = surf.AlphaClipThreshold;

         #if _AlphaClip
        		clip(Alpha - AlphaClipThreshold);
        #endif
                return 0;
            }

            ENDHLSL
        }

        Pass
        {
        	Name "DepthOnly"
            Tags{"LightMode" = "DepthOnly"}

            ZWrite On
            ColorMask 0

            // Material options generated by graph
            Cull Back

            HLSLPROGRAM
            // Required to compile gles 2.0 with standard srp library
            #pragma prefer_hlslcc gles
            #pragma exclude_renderers d3d11_9x
            #pragma target 2.0

            //--------------------------------------
            // GPU Instancing
            #pragma multi_compile_instancing

            #pragma vertex vert
            #pragma fragment frag

            // Defines generated by graph
            #define _NORMALMAP 1
            #define _AlphaClip 1

            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"

            CBUFFER_START(UnityPerMaterial)
            float _AlphaClipThreshold;
            float _Hue;
            float _Saturation;
            float _Lightness;
            CBUFFER_END

            TEXTURE2D(_Albedo); SAMPLER(sampler_Albedo); float4 _Albedo_TexelSize;
            TEXTURE2D(_BumpMap); SAMPLER(sampler_BumpMap); float4 _BumpMap_TexelSize;
            struct VertexDescriptionInputs
            {
                float3 WorldSpaceNormal;
                float3 WorldSpaceTangent;
                float3 WorldSpaceBiTangent;
                float3 ObjectSpacePosition;
            };

            struct SurfaceDescriptionInputs
            {
                float3 WorldSpaceNormal;
                float3 WorldSpaceTangent;
                float3 WorldSpaceBiTangent;
                half4 uv0;
            };


            void Unity_Subtract_float3(float3 A, float3 B, out float3 Out)
            {
                Out = A - B;
            }

            void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG)
            {
                RGBA = float4(R, G, B, A);
                RGB = float3(R, G, B);
                RG = float2(R, G);
            }

            void Unity_Normalize_float3(float3 In, out float3 Out)
            {
                Out = normalize(In);
            }

            void Unity_CrossProduct_float(float3 A, float3 B, out float3 Out)
            {
                Out = cross(A, B);
            }

            void Unity_Multiply_float (float3 A, float3 B, out float3 Out)
            {
                Out = A * B;
            }

            void Unity_Arctangent2_float(float A, float B, out float Out)
            {
                Out = atan2(A, B);
            }

            void Unity_RadiansToDegrees_float(float In, out float Out)
            {
                Out = degrees(In);
            }

            void Unity_Add_float(float A, float B, out float Out)
            {
                Out = A + B;
            }

            void Unity_Modulo_float(float A, float B, out float Out)
            {
                Out = fmod(A, B);
            }

            void Unity_Subtract_float(float A, float B, out float Out)
            {
                Out = A - B;
            }

            void Unity_Remap_float(float In, float2 InMinMax, float2 OutMinMax, out float Out)
            {
                Out = OutMinMax.x + (In - InMinMax.x) * (OutMinMax.y - OutMinMax.x) / (InMinMax.y - InMinMax.x);
            }

            void Unity_Floor_float(float In, out float Out)
            {
                Out = floor(In);
            }

            void Unity_Divide_float(float A, float B, out float Out)
            {
                Out = A / B;
            }

            void Unity_OneMinus_float(float In, out float Out)
            {
                Out = 1 - In;
            }

            void Unity_Multiply_float (float A, float B, out float Out)
            {
                Out = A * B;
            }

            void Unity_Divide_float4(float4 A, float4 B, out float4 Out)
            {
                Out = A / B;
            }

            void Unity_Add_float2(float2 A, float2 B, out float2 Out)
            {
                Out = A + B;
            }

            void Unity_Hue_Normalized_float(float3 In, float Offset, out float3 Out)
            {
                // RGB to HSV
                float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
                float4 P = lerp(float4(In.bg, K.wz), float4(In.gb, K.xy), step(In.b, In.g));
                float4 Q = lerp(float4(P.xyw, In.r), float4(In.r, P.yzx), step(P.x, In.r));
                float D = Q.x - min(Q.w, Q.y);
                float E = 1e-10;
                float3 hsv = float3(abs(Q.z + (Q.w - Q.y)/(6.0 * D + E)), D / (Q.x + E), Q.x);

                float hue = hsv.x + Offset;
                hsv.x = (hue < 0)
                        ? hue + 1
                        : (hue > 1)
                            ? hue - 1
                            : hue;

                // HSV to RGB
                float4 K2 = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                float3 P2 = abs(frac(hsv.xxx + K2.xyz) * 6.0 - K2.www);
                Out = hsv.z * lerp(K2.xxx, saturate(P2 - K2.xxx), hsv.y);
            }

            void Unity_Saturation_float(float3 In, float Saturation, out float3 Out)
            {
                float luma = dot(In, float3(0.2126729, 0.7151522, 0.0721750));
                Out =  luma.xxx + Saturation.xxx * (In - luma.xxx);
            }

            void Unity_Add_float3(float3 A, float3 B, out float3 Out)
            {
                Out = A + B;
            }

            struct VertexDescription
            {
                float3 Position;
            };

            VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
            {
                VertexDescription description = (VertexDescription)0;
                float _Split_FA827202_R_1 = IN.ObjectSpacePosition[0];
                float _Split_FA827202_G_2 = IN.ObjectSpacePosition[1];
                float _Split_FA827202_B_3 = IN.ObjectSpacePosition[2];
                float _Split_FA827202_A_4 = 0;
                float3 _Vector3_F70CD4C3_Out_0 = float3(_Split_FA827202_R_1, 0, _Split_FA827202_R_1);
                float3 _Subtract_74F98413_Out_2;
                Unity_Subtract_float3(SHADERGRAPH_OBJECT_POSITION, _WorldSpaceCameraPos, _Subtract_74F98413_Out_2);
                float _Split_67329DB8_R_1 = _Subtract_74F98413_Out_2[0];
                float _Split_67329DB8_G_2 = _Subtract_74F98413_Out_2[1];
                float _Split_67329DB8_B_3 = _Subtract_74F98413_Out_2[2];
                float _Split_67329DB8_A_4 = 0;
                float4 _Combine_F209DAD0_RGBA_4;
                float3 _Combine_F209DAD0_RGB_5;
                float2 _Combine_F209DAD0_RG_6;
                Unity_Combine_float(_Split_67329DB8_R_1, 0, _Split_67329DB8_B_3, 0, _Combine_F209DAD0_RGBA_4, _Combine_F209DAD0_RGB_5, _Combine_F209DAD0_RG_6);
                float3 _Normalize_1F9A769D_Out_1;
                Unity_Normalize_float3(_Combine_F209DAD0_RGB_5, _Normalize_1F9A769D_Out_1);
                float3 _Transform_C904C633_Out_1 = TransformWorldToObjectDir(_Normalize_1F9A769D_Out_1.xyz);
                float3 _Vector3_3F5F1FB6_Out_0 = float3(0, 1, 0);
                float3 _CrossProduct_ECD4E36B_Out_2;
                Unity_CrossProduct_float(_Transform_C904C633_Out_1, _Vector3_3F5F1FB6_Out_0, _CrossProduct_ECD4E36B_Out_2);
                float3 _Multiply_6B52A67B_Out_2;
                Unity_Multiply_float(_CrossProduct_ECD4E36B_Out_2, float3(-1, -1, -1), _Multiply_6B52A67B_Out_2);
                float3 _Multiply_95A81659_Out_2;
                Unity_Multiply_float(_Vector3_F70CD4C3_Out_0, _Multiply_6B52A67B_Out_2, _Multiply_95A81659_Out_2);
                float _Split_1A54F8B_R_1 = _Multiply_95A81659_Out_2[0];
                float _Split_1A54F8B_G_2 = _Multiply_95A81659_Out_2[1];
                float _Split_1A54F8B_B_3 = _Multiply_95A81659_Out_2[2];
                float _Split_1A54F8B_A_4 = 0;
                float4 _Combine_F763F954_RGBA_4;
                float3 _Combine_F763F954_RGB_5;
                float2 _Combine_F763F954_RG_6;
                Unity_Combine_float(_Split_1A54F8B_R_1, _Split_FA827202_G_2, _Split_1A54F8B_B_3, 0, _Combine_F763F954_RGBA_4, _Combine_F763F954_RGB_5, _Combine_F763F954_RG_6);
                description.Position = _Combine_F763F954_RGB_5;
                return description;
            }

            struct SurfaceDescription
            {
                float3 Albedo;
                float3 Emission;
                float Alpha;
                float AlphaClipThreshold;
            };

            SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
            {
                SurfaceDescription surface = (SurfaceDescription)0;
                float3 _Subtract_74F98413_Out_2;
                Unity_Subtract_float3(SHADERGRAPH_OBJECT_POSITION, _WorldSpaceCameraPos, _Subtract_74F98413_Out_2);
                float _Split_67329DB8_R_1 = _Subtract_74F98413_Out_2[0];
                float _Split_67329DB8_G_2 = _Subtract_74F98413_Out_2[1];
                float _Split_67329DB8_B_3 = _Subtract_74F98413_Out_2[2];
                float _Split_67329DB8_A_4 = 0;
                float4 _Combine_F209DAD0_RGBA_4;
                float3 _Combine_F209DAD0_RGB_5;
                float2 _Combine_F209DAD0_RG_6;
                Unity_Combine_float(_Split_67329DB8_R_1, 0, _Split_67329DB8_B_3, 0, _Combine_F209DAD0_RGBA_4, _Combine_F209DAD0_RGB_5, _Combine_F209DAD0_RG_6);
                float3 _Normalize_1F9A769D_Out_1;
                Unity_Normalize_float3(_Combine_F209DAD0_RGB_5, _Normalize_1F9A769D_Out_1);
                float3 _Transform_C904C633_Out_1 = TransformWorldToObjectDir(_Normalize_1F9A769D_Out_1.xyz);
                float _Split_ADCD8D4F_R_1 = _Transform_C904C633_Out_1[0];
                float _Split_ADCD8D4F_G_2 = _Transform_C904C633_Out_1[1];
                float _Split_ADCD8D4F_B_3 = _Transform_C904C633_Out_1[2];
                float _Split_ADCD8D4F_A_4 = 0;
                float _Arctangent2_4039E87E_Out_2;
                Unity_Arctangent2_float(_Split_ADCD8D4F_B_3, _Split_ADCD8D4F_R_1, _Arctangent2_4039E87E_Out_2);
                float _RadiansToDegrees_822E9378_Out_1;
                Unity_RadiansToDegrees_float(_Arctangent2_4039E87E_Out_2, _RadiansToDegrees_822E9378_Out_1);
                float _Add_F423FB93_Out_2;
                Unity_Add_float(_RadiansToDegrees_822E9378_Out_1, 0, _Add_F423FB93_Out_2);
                float _Add_B5DF3C81_Out_2;
                Unity_Add_float(_Add_F423FB93_Out_2, 90, _Add_B5DF3C81_Out_2);
                float _Modulo_E642AF79_Out_2;
                Unity_Modulo_float(_Add_B5DF3C81_Out_2, 360, _Modulo_E642AF79_Out_2);
                float _Subtract_420DDE08_Out_2;
                Unity_Subtract_float(360, _Modulo_E642AF79_Out_2, _Subtract_420DDE08_Out_2);
                float _Remap_859F7A9D_Out_3;
                Unity_Remap_float(_Subtract_420DDE08_Out_2, float2 (0, 360), float2 (0, 16), _Remap_859F7A9D_Out_3);
                float _Floor_AE29D009_Out_1;
                Unity_Floor_float(_Remap_859F7A9D_Out_3, _Floor_AE29D009_Out_1);
                float _Divide_EC99B270_Out_2;
                Unity_Divide_float(_Floor_AE29D009_Out_1, 4, _Divide_EC99B270_Out_2);
                float _Floor_BECE6315_Out_1;
                Unity_Floor_float(_Divide_EC99B270_Out_2, _Floor_BECE6315_Out_1);
                float _Divide_5696F1A6_Out_2;
                Unity_Divide_float(_Floor_BECE6315_Out_1, 4, _Divide_5696F1A6_Out_2);
                float _OneMinus_3DBE3279_Out_1;
                Unity_OneMinus_float(_Divide_5696F1A6_Out_2, _OneMinus_3DBE3279_Out_1);
                float _Multiply_D3C5014D_Out_2;
                Unity_Multiply_float(_Floor_BECE6315_Out_1, 4, _Multiply_D3C5014D_Out_2);
                float _Subtract_1796B96F_Out_2;
                Unity_Subtract_float(_Floor_AE29D009_Out_1, _Multiply_D3C5014D_Out_2, _Subtract_1796B96F_Out_2);
                float _Divide_F6C8A2F_Out_2;
                Unity_Divide_float(_Subtract_1796B96F_Out_2, 4, _Divide_F6C8A2F_Out_2);
                float2 _Vector2_7D220493_Out_0 = float2(_OneMinus_3DBE3279_Out_1, _Divide_F6C8A2F_Out_2);
                float4 _UV_76C93B5D_Out_0 = IN.uv0;
                float4 _Divide_9FCFC3DD_Out_2;
                Unity_Divide_float4(_UV_76C93B5D_Out_0, float4(4, 4, 4, 4), _Divide_9FCFC3DD_Out_2);
                float2 _Add_C3699259_Out_2;
                Unity_Add_float2(_Vector2_7D220493_Out_0, (_Divide_9FCFC3DD_Out_2.xy), _Add_C3699259_Out_2);
                float4 _SampleTexture2D_29A29D61_RGBA_0 = SAMPLE_TEXTURE2D(_Albedo, sampler_Albedo, _Add_C3699259_Out_2);
                float _SampleTexture2D_29A29D61_R_4 = _SampleTexture2D_29A29D61_RGBA_0.r;
                float _SampleTexture2D_29A29D61_G_5 = _SampleTexture2D_29A29D61_RGBA_0.g;
                float _SampleTexture2D_29A29D61_B_6 = _SampleTexture2D_29A29D61_RGBA_0.b;
                float _SampleTexture2D_29A29D61_A_7 = _SampleTexture2D_29A29D61_RGBA_0.a;
                float _Property_A51D11B2_Out_0 = _Hue;
                float3 _Hue_D09989EF_Out_2;
                Unity_Hue_Normalized_float((_SampleTexture2D_29A29D61_RGBA_0.xyz), _Property_A51D11B2_Out_0, _Hue_D09989EF_Out_2);
                float _Property_3C770CFC_Out_0 = _Saturation;
                float _Add_515FA5ED_Out_2;
                Unity_Add_float(_Property_3C770CFC_Out_0, 1, _Add_515FA5ED_Out_2);
                float3 _Saturation_843CD1F5_Out_2;
                Unity_Saturation_float(_Hue_D09989EF_Out_2, _Add_515FA5ED_Out_2, _Saturation_843CD1F5_Out_2);
                float _Property_93DBCFB9_Out_0 = _Lightness;
                float3 _Add_52C2111C_Out_2;
                Unity_Add_float3(_Saturation_843CD1F5_Out_2, (_Property_93DBCFB9_Out_0.xxx), _Add_52C2111C_Out_2);
                float _Property_DA5F57E_Out_0 = _AlphaClipThreshold;
                surface.Albedo = _Add_52C2111C_Out_2;
                surface.Emission = IsGammaSpace() ? float3(0, 0, 0) : SRGBToLinear(float3(0, 0, 0));
                surface.Alpha = _SampleTexture2D_29A29D61_A_7;
                surface.AlphaClipThreshold = _Property_DA5F57E_Out_0;
                return surface;
            }

            struct GraphVertexInput
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 tangent : TANGENT;
                float4 texcoord0 : TEXCOORD0;
                float4 texcoord1 : TEXCOORD1;
                UNITY_VERTEX_INPUT_INSTANCE_ID
            };


        	struct VertexOutput
        	{
        	    float2 uv           : TEXCOORD0;
        	    float4 clipPos      : SV_POSITION;
                // Interpolators defined by graph
                float3 WorldSpacePosition : TEXCOORD3;
                float3 WorldSpaceNormal : TEXCOORD4;
                float3 WorldSpaceTangent : TEXCOORD5;
                float3 WorldSpaceBiTangent : TEXCOORD6;
                float3 WorldSpaceViewDirection : TEXCOORD7;
                half4 uv0 : TEXCOORD8;
                half4 uv1 : TEXCOORD9;

                UNITY_VERTEX_INPUT_INSTANCE_ID
                UNITY_VERTEX_OUTPUT_STEREO
        	};

            VertexOutput vert(GraphVertexInput v)
            {
                VertexOutput o = (VertexOutput)0;
        	    UNITY_SETUP_INSTANCE_ID(v);
                UNITY_TRANSFER_INSTANCE_ID(v, o);
                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

        	    // Vertex transformations performed by graph
                float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
                float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
                float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
                float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
                float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
                float4 uv0 = v.texcoord0;
                float4 uv1 = v.texcoord1;
                float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;

        		VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

                // Vertex description inputs defined by graph
                vdi.WorldSpaceNormal = WorldSpaceNormal;
                vdi.WorldSpaceTangent = WorldSpaceTangent;
                vdi.WorldSpaceBiTangent = WorldSpaceBiTangent;
                vdi.ObjectSpacePosition = ObjectSpacePosition;

        	    VertexDescription vd = PopulateVertexData(vdi);
                v.vertex.xyz = vd.Position;

        	    // Vertex shader outputs defined by graph
                o.WorldSpacePosition = WorldSpacePosition;
                o.WorldSpaceNormal = WorldSpaceNormal;
                o.WorldSpaceTangent = WorldSpaceTangent;
                o.WorldSpaceBiTangent = WorldSpaceBiTangent;
                o.WorldSpaceViewDirection = WorldSpaceViewDirection;
                o.uv0 = uv0;
                o.uv1 = uv1;

        	    o.clipPos = TransformObjectToHClip(v.vertex.xyz);
        	    return o;
            }

            half4 frag(VertexOutput IN ) : SV_TARGET
            {
                UNITY_SETUP_INSTANCE_ID(IN);
        		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);

                // Pixel transformations performed by graph
                float3 WorldSpacePosition = IN.WorldSpacePosition;
                float3 WorldSpaceNormal = IN.WorldSpaceNormal;
                float3 WorldSpaceTangent = IN.WorldSpaceTangent;
                float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
                float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
                float4 uv0 = IN.uv0;
                float4 uv1 = IN.uv1;

                SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

        		// Surface description inputs defined by graph
                surfaceInput.WorldSpaceNormal = WorldSpaceNormal;
                surfaceInput.WorldSpaceTangent = WorldSpaceTangent;
                surfaceInput.WorldSpaceBiTangent = WorldSpaceBiTangent;
                surfaceInput.uv0 = uv0;

                SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

                float3 Albedo = float3(0.5, 0.5, 0.5);
        		float3 Emission = 0;
        		float Alpha = 1;
        		float AlphaClipThreshold = 0;

        		// Surface description remap performed by graph
                Albedo = surf.Albedo;
                Emission = surf.Emission;
                Alpha = surf.Alpha;
                AlphaClipThreshold = surf.AlphaClipThreshold;

         #if _AlphaClip
        		clip(Alpha - AlphaClipThreshold);
        #endif
                return 0;
            }
            ENDHLSL
        }

        // This pass it not used during regular rendering, only for lightmap baking.
        Pass
        {
        	Name "Meta"
            Tags{"LightMode" = "Meta"}

            Cull Off

            HLSLPROGRAM
            // Required to compile gles 2.0 with standard srp library
            #pragma prefer_hlslcc gles
            #pragma exclude_renderers d3d11_9x
            #pragma target 2.0

            #pragma vertex vert
            #pragma fragment frag

            float4 _MainTex_ST;

            // Defines generated by graph
            #define _NORMALMAP 1
            #define _AlphaClip 1

            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/MetaInput.hlsl"
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"

            #pragma shader_feature _ _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A

                CBUFFER_START(UnityPerMaterial)
            float _AlphaClipThreshold;
            float _Hue;
            float _Saturation;
            float _Lightness;
            CBUFFER_END

            TEXTURE2D(_Albedo); SAMPLER(sampler_Albedo); float4 _Albedo_TexelSize;
            TEXTURE2D(_BumpMap); SAMPLER(sampler_BumpMap); float4 _BumpMap_TexelSize;
            struct VertexDescriptionInputs
            {
                float3 WorldSpaceNormal;
                float3 WorldSpaceTangent;
                float3 WorldSpaceBiTangent;
                float3 ObjectSpacePosition;
            };

            struct SurfaceDescriptionInputs
            {
                float3 WorldSpaceNormal;
                float3 WorldSpaceTangent;
                float3 WorldSpaceBiTangent;
                half4 uv0;
            };


            void Unity_Subtract_float3(float3 A, float3 B, out float3 Out)
            {
                Out = A - B;
            }

            void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG)
            {
                RGBA = float4(R, G, B, A);
                RGB = float3(R, G, B);
                RG = float2(R, G);
            }

            void Unity_Normalize_float3(float3 In, out float3 Out)
            {
                Out = normalize(In);
            }

            void Unity_CrossProduct_float(float3 A, float3 B, out float3 Out)
            {
                Out = cross(A, B);
            }

            void Unity_Multiply_float (float3 A, float3 B, out float3 Out)
            {
                Out = A * B;
            }

            void Unity_Arctangent2_float(float A, float B, out float Out)
            {
                Out = atan2(A, B);
            }

            void Unity_RadiansToDegrees_float(float In, out float Out)
            {
                Out = degrees(In);
            }

            void Unity_Add_float(float A, float B, out float Out)
            {
                Out = A + B;
            }

            void Unity_Modulo_float(float A, float B, out float Out)
            {
                Out = fmod(A, B);
            }

            void Unity_Subtract_float(float A, float B, out float Out)
            {
                Out = A - B;
            }

            void Unity_Remap_float(float In, float2 InMinMax, float2 OutMinMax, out float Out)
            {
                Out = OutMinMax.x + (In - InMinMax.x) * (OutMinMax.y - OutMinMax.x) / (InMinMax.y - InMinMax.x);
            }

            void Unity_Floor_float(float In, out float Out)
            {
                Out = floor(In);
            }

            void Unity_Divide_float(float A, float B, out float Out)
            {
                Out = A / B;
            }

            void Unity_OneMinus_float(float In, out float Out)
            {
                Out = 1 - In;
            }

            void Unity_Multiply_float (float A, float B, out float Out)
            {
                Out = A * B;
            }

            void Unity_Divide_float4(float4 A, float4 B, out float4 Out)
            {
                Out = A / B;
            }

            void Unity_Add_float2(float2 A, float2 B, out float2 Out)
            {
                Out = A + B;
            }

            void Unity_Hue_Normalized_float(float3 In, float Offset, out float3 Out)
            {
                // RGB to HSV
                float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
                float4 P = lerp(float4(In.bg, K.wz), float4(In.gb, K.xy), step(In.b, In.g));
                float4 Q = lerp(float4(P.xyw, In.r), float4(In.r, P.yzx), step(P.x, In.r));
                float D = Q.x - min(Q.w, Q.y);
                float E = 1e-10;
                float3 hsv = float3(abs(Q.z + (Q.w - Q.y)/(6.0 * D + E)), D / (Q.x + E), Q.x);

                float hue = hsv.x + Offset;
                hsv.x = (hue < 0)
                        ? hue + 1
                        : (hue > 1)
                            ? hue - 1
                            : hue;

                // HSV to RGB
                float4 K2 = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                float3 P2 = abs(frac(hsv.xxx + K2.xyz) * 6.0 - K2.www);
                Out = hsv.z * lerp(K2.xxx, saturate(P2 - K2.xxx), hsv.y);
            }

            void Unity_Saturation_float(float3 In, float Saturation, out float3 Out)
            {
                float luma = dot(In, float3(0.2126729, 0.7151522, 0.0721750));
                Out =  luma.xxx + Saturation.xxx * (In - luma.xxx);
            }

            void Unity_Add_float3(float3 A, float3 B, out float3 Out)
            {
                Out = A + B;
            }

            struct VertexDescription
            {
                float3 Position;
            };

            VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
            {
                VertexDescription description = (VertexDescription)0;
                float _Split_FA827202_R_1 = IN.ObjectSpacePosition[0];
                float _Split_FA827202_G_2 = IN.ObjectSpacePosition[1];
                float _Split_FA827202_B_3 = IN.ObjectSpacePosition[2];
                float _Split_FA827202_A_4 = 0;
                float3 _Vector3_F70CD4C3_Out_0 = float3(_Split_FA827202_R_1, 0, _Split_FA827202_R_1);
                float3 _Subtract_74F98413_Out_2;
                Unity_Subtract_float3(SHADERGRAPH_OBJECT_POSITION, _WorldSpaceCameraPos, _Subtract_74F98413_Out_2);
                float _Split_67329DB8_R_1 = _Subtract_74F98413_Out_2[0];
                float _Split_67329DB8_G_2 = _Subtract_74F98413_Out_2[1];
                float _Split_67329DB8_B_3 = _Subtract_74F98413_Out_2[2];
                float _Split_67329DB8_A_4 = 0;
                float4 _Combine_F209DAD0_RGBA_4;
                float3 _Combine_F209DAD0_RGB_5;
                float2 _Combine_F209DAD0_RG_6;
                Unity_Combine_float(_Split_67329DB8_R_1, 0, _Split_67329DB8_B_3, 0, _Combine_F209DAD0_RGBA_4, _Combine_F209DAD0_RGB_5, _Combine_F209DAD0_RG_6);
                float3 _Normalize_1F9A769D_Out_1;
                Unity_Normalize_float3(_Combine_F209DAD0_RGB_5, _Normalize_1F9A769D_Out_1);
                float3 _Transform_C904C633_Out_1 = TransformWorldToObjectDir(_Normalize_1F9A769D_Out_1.xyz);
                float3 _Vector3_3F5F1FB6_Out_0 = float3(0, 1, 0);
                float3 _CrossProduct_ECD4E36B_Out_2;
                Unity_CrossProduct_float(_Transform_C904C633_Out_1, _Vector3_3F5F1FB6_Out_0, _CrossProduct_ECD4E36B_Out_2);
                float3 _Multiply_6B52A67B_Out_2;
                Unity_Multiply_float(_CrossProduct_ECD4E36B_Out_2, float3(-1, -1, -1), _Multiply_6B52A67B_Out_2);
                float3 _Multiply_95A81659_Out_2;
                Unity_Multiply_float(_Vector3_F70CD4C3_Out_0, _Multiply_6B52A67B_Out_2, _Multiply_95A81659_Out_2);
                float _Split_1A54F8B_R_1 = _Multiply_95A81659_Out_2[0];
                float _Split_1A54F8B_G_2 = _Multiply_95A81659_Out_2[1];
                float _Split_1A54F8B_B_3 = _Multiply_95A81659_Out_2[2];
                float _Split_1A54F8B_A_4 = 0;
                float4 _Combine_F763F954_RGBA_4;
                float3 _Combine_F763F954_RGB_5;
                float2 _Combine_F763F954_RG_6;
                Unity_Combine_float(_Split_1A54F8B_R_1, _Split_FA827202_G_2, _Split_1A54F8B_B_3, 0, _Combine_F763F954_RGBA_4, _Combine_F763F954_RGB_5, _Combine_F763F954_RG_6);
                description.Position = _Combine_F763F954_RGB_5;
                return description;
            }

            struct SurfaceDescription
            {
                float3 Albedo;
                float3 Emission;
                float Alpha;
                float AlphaClipThreshold;
            };

            SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
            {
                SurfaceDescription surface = (SurfaceDescription)0;
                float3 _Subtract_74F98413_Out_2;
                Unity_Subtract_float3(SHADERGRAPH_OBJECT_POSITION, _WorldSpaceCameraPos, _Subtract_74F98413_Out_2);
                float _Split_67329DB8_R_1 = _Subtract_74F98413_Out_2[0];
                float _Split_67329DB8_G_2 = _Subtract_74F98413_Out_2[1];
                float _Split_67329DB8_B_3 = _Subtract_74F98413_Out_2[2];
                float _Split_67329DB8_A_4 = 0;
                float4 _Combine_F209DAD0_RGBA_4;
                float3 _Combine_F209DAD0_RGB_5;
                float2 _Combine_F209DAD0_RG_6;
                Unity_Combine_float(_Split_67329DB8_R_1, 0, _Split_67329DB8_B_3, 0, _Combine_F209DAD0_RGBA_4, _Combine_F209DAD0_RGB_5, _Combine_F209DAD0_RG_6);
                float3 _Normalize_1F9A769D_Out_1;
                Unity_Normalize_float3(_Combine_F209DAD0_RGB_5, _Normalize_1F9A769D_Out_1);
                float3 _Transform_C904C633_Out_1 = TransformWorldToObjectDir(_Normalize_1F9A769D_Out_1.xyz);
                float _Split_ADCD8D4F_R_1 = _Transform_C904C633_Out_1[0];
                float _Split_ADCD8D4F_G_2 = _Transform_C904C633_Out_1[1];
                float _Split_ADCD8D4F_B_3 = _Transform_C904C633_Out_1[2];
                float _Split_ADCD8D4F_A_4 = 0;
                float _Arctangent2_4039E87E_Out_2;
                Unity_Arctangent2_float(_Split_ADCD8D4F_B_3, _Split_ADCD8D4F_R_1, _Arctangent2_4039E87E_Out_2);
                float _RadiansToDegrees_822E9378_Out_1;
                Unity_RadiansToDegrees_float(_Arctangent2_4039E87E_Out_2, _RadiansToDegrees_822E9378_Out_1);
                float _Add_F423FB93_Out_2;
                Unity_Add_float(_RadiansToDegrees_822E9378_Out_1, 0, _Add_F423FB93_Out_2);
                float _Add_B5DF3C81_Out_2;
                Unity_Add_float(_Add_F423FB93_Out_2, 90, _Add_B5DF3C81_Out_2);
                float _Modulo_E642AF79_Out_2;
                Unity_Modulo_float(_Add_B5DF3C81_Out_2, 360, _Modulo_E642AF79_Out_2);
                float _Subtract_420DDE08_Out_2;
                Unity_Subtract_float(360, _Modulo_E642AF79_Out_2, _Subtract_420DDE08_Out_2);
                float _Remap_859F7A9D_Out_3;
                Unity_Remap_float(_Subtract_420DDE08_Out_2, float2 (0, 360), float2 (0, 16), _Remap_859F7A9D_Out_3);
                float _Floor_AE29D009_Out_1;
                Unity_Floor_float(_Remap_859F7A9D_Out_3, _Floor_AE29D009_Out_1);
                float _Divide_EC99B270_Out_2;
                Unity_Divide_float(_Floor_AE29D009_Out_1, 4, _Divide_EC99B270_Out_2);
                float _Floor_BECE6315_Out_1;
                Unity_Floor_float(_Divide_EC99B270_Out_2, _Floor_BECE6315_Out_1);
                float _Divide_5696F1A6_Out_2;
                Unity_Divide_float(_Floor_BECE6315_Out_1, 4, _Divide_5696F1A6_Out_2);
                float _OneMinus_3DBE3279_Out_1;
                Unity_OneMinus_float(_Divide_5696F1A6_Out_2, _OneMinus_3DBE3279_Out_1);
                float _Multiply_D3C5014D_Out_2;
                Unity_Multiply_float(_Floor_BECE6315_Out_1, 4, _Multiply_D3C5014D_Out_2);
                float _Subtract_1796B96F_Out_2;
                Unity_Subtract_float(_Floor_AE29D009_Out_1, _Multiply_D3C5014D_Out_2, _Subtract_1796B96F_Out_2);
                float _Divide_F6C8A2F_Out_2;
                Unity_Divide_float(_Subtract_1796B96F_Out_2, 4, _Divide_F6C8A2F_Out_2);
                float2 _Vector2_7D220493_Out_0 = float2(_OneMinus_3DBE3279_Out_1, _Divide_F6C8A2F_Out_2);
                float4 _UV_76C93B5D_Out_0 = IN.uv0;
                float4 _Divide_9FCFC3DD_Out_2;
                Unity_Divide_float4(_UV_76C93B5D_Out_0, float4(4, 4, 4, 4), _Divide_9FCFC3DD_Out_2);
                float2 _Add_C3699259_Out_2;
                Unity_Add_float2(_Vector2_7D220493_Out_0, (_Divide_9FCFC3DD_Out_2.xy), _Add_C3699259_Out_2);
                float4 _SampleTexture2D_29A29D61_RGBA_0 = SAMPLE_TEXTURE2D(_Albedo, sampler_Albedo, _Add_C3699259_Out_2);
                float _SampleTexture2D_29A29D61_R_4 = _SampleTexture2D_29A29D61_RGBA_0.r;
                float _SampleTexture2D_29A29D61_G_5 = _SampleTexture2D_29A29D61_RGBA_0.g;
                float _SampleTexture2D_29A29D61_B_6 = _SampleTexture2D_29A29D61_RGBA_0.b;
                float _SampleTexture2D_29A29D61_A_7 = _SampleTexture2D_29A29D61_RGBA_0.a;
                float _Property_A51D11B2_Out_0 = _Hue;
                float3 _Hue_D09989EF_Out_2;
                Unity_Hue_Normalized_float((_SampleTexture2D_29A29D61_RGBA_0.xyz), _Property_A51D11B2_Out_0, _Hue_D09989EF_Out_2);
                float _Property_3C770CFC_Out_0 = _Saturation;
                float _Add_515FA5ED_Out_2;
                Unity_Add_float(_Property_3C770CFC_Out_0, 1, _Add_515FA5ED_Out_2);
                float3 _Saturation_843CD1F5_Out_2;
                Unity_Saturation_float(_Hue_D09989EF_Out_2, _Add_515FA5ED_Out_2, _Saturation_843CD1F5_Out_2);
                float _Property_93DBCFB9_Out_0 = _Lightness;
                float3 _Add_52C2111C_Out_2;
                Unity_Add_float3(_Saturation_843CD1F5_Out_2, (_Property_93DBCFB9_Out_0.xxx), _Add_52C2111C_Out_2);
                float _Property_DA5F57E_Out_0 = _AlphaClipThreshold;
                surface.Albedo = _Add_52C2111C_Out_2;
                surface.Emission = IsGammaSpace() ? float3(0, 0, 0) : SRGBToLinear(float3(0, 0, 0));
                surface.Alpha = _SampleTexture2D_29A29D61_A_7;
                surface.AlphaClipThreshold = _Property_DA5F57E_Out_0;
                return surface;
            }

            struct GraphVertexInput
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 tangent : TANGENT;
                float4 texcoord0 : TEXCOORD0;
                float4 texcoord1 : TEXCOORD1;
                UNITY_VERTEX_INPUT_INSTANCE_ID
            };


        	struct VertexOutput
        	{
        	    float2 uv           : TEXCOORD0;
        	    float4 clipPos      : SV_POSITION;
                // Interpolators defined by graph
                float3 WorldSpacePosition : TEXCOORD3;
                float3 WorldSpaceNormal : TEXCOORD4;
                float3 WorldSpaceTangent : TEXCOORD5;
                float3 WorldSpaceBiTangent : TEXCOORD6;
                float3 WorldSpaceViewDirection : TEXCOORD7;
                half4 uv0 : TEXCOORD8;
                half4 uv1 : TEXCOORD9;

                UNITY_VERTEX_INPUT_INSTANCE_ID
                UNITY_VERTEX_OUTPUT_STEREO
        	};

            VertexOutput vert(GraphVertexInput v)
            {
                VertexOutput o = (VertexOutput)0;
        	    UNITY_SETUP_INSTANCE_ID(v);
                UNITY_TRANSFER_INSTANCE_ID(v, o);
                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

        	    // Vertex transformations performed by graph
                float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
                float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
                float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
                float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
                float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
                float4 uv0 = v.texcoord0;
                float4 uv1 = v.texcoord1;
                float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;


        	    // Vertex shader outputs defined by graph
                o.WorldSpacePosition = WorldSpacePosition;
                o.WorldSpaceNormal = WorldSpaceNormal;
                o.WorldSpaceTangent = WorldSpaceTangent;
                o.WorldSpaceBiTangent = WorldSpaceBiTangent;
                o.WorldSpaceViewDirection = WorldSpaceViewDirection;
                o.uv0 = uv0;
                o.uv1 = uv1;

                o.clipPos = MetaVertexPosition(v.vertex, uv1, uv1, unity_LightmapST, unity_DynamicLightmapST);
        	    return o;
            }

            half4 frag(VertexOutput IN ) : SV_TARGET
            {
                UNITY_SETUP_INSTANCE_ID(IN);
        		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);

                // Pixel transformations performed by graph
                float3 WorldSpacePosition = IN.WorldSpacePosition;
                float3 WorldSpaceNormal = IN.WorldSpaceNormal;
                float3 WorldSpaceTangent = IN.WorldSpaceTangent;
                float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
                float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
                float4 uv0 = IN.uv0;
                float4 uv1 = IN.uv1;

                SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

        		// Surface description inputs defined by graph
                surfaceInput.WorldSpaceNormal = WorldSpaceNormal;
                surfaceInput.WorldSpaceTangent = WorldSpaceTangent;
                surfaceInput.WorldSpaceBiTangent = WorldSpaceBiTangent;
                surfaceInput.uv0 = uv0;

                SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

        		float3 Albedo = float3(0.5, 0.5, 0.5);
        		float3 Emission = 0;
        		float Alpha = 1;
        		float AlphaClipThreshold = 0;

        		// Surface description remap performed by graph
                Albedo = surf.Albedo;
                Emission = surf.Emission;
                Alpha = surf.Alpha;
                AlphaClipThreshold = surf.AlphaClipThreshold;

         #if _AlphaClip
        		clip(Alpha - AlphaClipThreshold);
        #endif

                MetaInput metaInput = (MetaInput)0;
                metaInput.Albedo = Albedo;
                metaInput.Emission = Emission;
                
                return MetaFragment(metaInput);
            }
            ENDHLSL
        }
        Pass
        {
        	Tags{"LightMode" = "Universal2D"}

        	// Material options generated by graph

            Blend One Zero, One Zero

            Cull Back

            ZTest LEqual

            ZWrite On

        	HLSLPROGRAM
            // Required to compile gles 2.0 with standard srp library
            #pragma enable_d3d11_debug_symbols
            #pragma prefer_hlslcc gles
            #pragma exclude_renderers d3d11_9x
            #pragma target 2.0

            #pragma vertex vert
        	#pragma fragment frag

        	// Defines generated by graph
            #define _NORMALMAP 1
            #define _AlphaClip 1

        	#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
        	#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/UnityInstancing.hlsl"
        	#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl"

            CBUFFER_START(UnityPerMaterial)
            float _AlphaClipThreshold;
            float _Hue;
            float _Saturation;
            float _Lightness;
            CBUFFER_END

            TEXTURE2D(_Albedo); SAMPLER(sampler_Albedo); float4 _Albedo_TexelSize;
            TEXTURE2D(_BumpMap); SAMPLER(sampler_BumpMap); float4 _BumpMap_TexelSize;
            struct VertexDescriptionInputs
            {
                float3 WorldSpaceNormal;
                float3 WorldSpaceTangent;
                float3 WorldSpaceBiTangent;
                float3 ObjectSpacePosition;
            };

            struct SurfaceDescriptionInputs
            {
                float3 WorldSpaceNormal;
                float3 WorldSpaceTangent;
                float3 WorldSpaceBiTangent;
                half4 uv0;
            };


            void Unity_Subtract_float3(float3 A, float3 B, out float3 Out)
            {
                Out = A - B;
            }

            void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG)
            {
                RGBA = float4(R, G, B, A);
                RGB = float3(R, G, B);
                RG = float2(R, G);
            }

            void Unity_Normalize_float3(float3 In, out float3 Out)
            {
                Out = normalize(In);
            }

            void Unity_CrossProduct_float(float3 A, float3 B, out float3 Out)
            {
                Out = cross(A, B);
            }

            void Unity_Multiply_float (float3 A, float3 B, out float3 Out)
            {
                Out = A * B;
            }

            void Unity_Arctangent2_float(float A, float B, out float Out)
            {
                Out = atan2(A, B);
            }

            void Unity_RadiansToDegrees_float(float In, out float Out)
            {
                Out = degrees(In);
            }

            void Unity_Add_float(float A, float B, out float Out)
            {
                Out = A + B;
            }

            void Unity_Modulo_float(float A, float B, out float Out)
            {
                Out = fmod(A, B);
            }

            void Unity_Subtract_float(float A, float B, out float Out)
            {
                Out = A - B;
            }

            void Unity_Remap_float(float In, float2 InMinMax, float2 OutMinMax, out float Out)
            {
                Out = OutMinMax.x + (In - InMinMax.x) * (OutMinMax.y - OutMinMax.x) / (InMinMax.y - InMinMax.x);
            }

            void Unity_Floor_float(float In, out float Out)
            {
                Out = floor(In);
            }

            void Unity_Divide_float(float A, float B, out float Out)
            {
                Out = A / B;
            }

            void Unity_OneMinus_float(float In, out float Out)
            {
                Out = 1 - In;
            }

            void Unity_Multiply_float (float A, float B, out float Out)
            {
                Out = A * B;
            }

            void Unity_Divide_float4(float4 A, float4 B, out float4 Out)
            {
                Out = A / B;
            }

            void Unity_Add_float2(float2 A, float2 B, out float2 Out)
            {
                Out = A + B;
            }

            void Unity_Hue_Normalized_float(float3 In, float Offset, out float3 Out)
            {
                // RGB to HSV
                float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
                float4 P = lerp(float4(In.bg, K.wz), float4(In.gb, K.xy), step(In.b, In.g));
                float4 Q = lerp(float4(P.xyw, In.r), float4(In.r, P.yzx), step(P.x, In.r));
                float D = Q.x - min(Q.w, Q.y);
                float E = 1e-10;
                float3 hsv = float3(abs(Q.z + (Q.w - Q.y)/(6.0 * D + E)), D / (Q.x + E), Q.x);

                float hue = hsv.x + Offset;
                hsv.x = (hue < 0)
                        ? hue + 1
                        : (hue > 1)
                            ? hue - 1
                            : hue;

                // HSV to RGB
                float4 K2 = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                float3 P2 = abs(frac(hsv.xxx + K2.xyz) * 6.0 - K2.www);
                Out = hsv.z * lerp(K2.xxx, saturate(P2 - K2.xxx), hsv.y);
            }

            void Unity_Saturation_float(float3 In, float Saturation, out float3 Out)
            {
                float luma = dot(In, float3(0.2126729, 0.7151522, 0.0721750));
                Out =  luma.xxx + Saturation.xxx * (In - luma.xxx);
            }

            void Unity_Add_float3(float3 A, float3 B, out float3 Out)
            {
                Out = A + B;
            }

            struct VertexDescription
            {
                float3 Position;
            };

            VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
            {
                VertexDescription description = (VertexDescription)0;
                float _Split_FA827202_R_1 = IN.ObjectSpacePosition[0];
                float _Split_FA827202_G_2 = IN.ObjectSpacePosition[1];
                float _Split_FA827202_B_3 = IN.ObjectSpacePosition[2];
                float _Split_FA827202_A_4 = 0;
                float3 _Vector3_F70CD4C3_Out_0 = float3(_Split_FA827202_R_1, 0, _Split_FA827202_R_1);
                float3 _Subtract_74F98413_Out_2;
                Unity_Subtract_float3(SHADERGRAPH_OBJECT_POSITION, _WorldSpaceCameraPos, _Subtract_74F98413_Out_2);
                float _Split_67329DB8_R_1 = _Subtract_74F98413_Out_2[0];
                float _Split_67329DB8_G_2 = _Subtract_74F98413_Out_2[1];
                float _Split_67329DB8_B_3 = _Subtract_74F98413_Out_2[2];
                float _Split_67329DB8_A_4 = 0;
                float4 _Combine_F209DAD0_RGBA_4;
                float3 _Combine_F209DAD0_RGB_5;
                float2 _Combine_F209DAD0_RG_6;
                Unity_Combine_float(_Split_67329DB8_R_1, 0, _Split_67329DB8_B_3, 0, _Combine_F209DAD0_RGBA_4, _Combine_F209DAD0_RGB_5, _Combine_F209DAD0_RG_6);
                float3 _Normalize_1F9A769D_Out_1;
                Unity_Normalize_float3(_Combine_F209DAD0_RGB_5, _Normalize_1F9A769D_Out_1);
                float3 _Transform_C904C633_Out_1 = TransformWorldToObjectDir(_Normalize_1F9A769D_Out_1.xyz);
                float3 _Vector3_3F5F1FB6_Out_0 = float3(0, 1, 0);
                float3 _CrossProduct_ECD4E36B_Out_2;
                Unity_CrossProduct_float(_Transform_C904C633_Out_1, _Vector3_3F5F1FB6_Out_0, _CrossProduct_ECD4E36B_Out_2);
                float3 _Multiply_6B52A67B_Out_2;
                Unity_Multiply_float(_CrossProduct_ECD4E36B_Out_2, float3(-1, -1, -1), _Multiply_6B52A67B_Out_2);
                float3 _Multiply_95A81659_Out_2;
                Unity_Multiply_float(_Vector3_F70CD4C3_Out_0, _Multiply_6B52A67B_Out_2, _Multiply_95A81659_Out_2);
                float _Split_1A54F8B_R_1 = _Multiply_95A81659_Out_2[0];
                float _Split_1A54F8B_G_2 = _Multiply_95A81659_Out_2[1];
                float _Split_1A54F8B_B_3 = _Multiply_95A81659_Out_2[2];
                float _Split_1A54F8B_A_4 = 0;
                float4 _Combine_F763F954_RGBA_4;
                float3 _Combine_F763F954_RGB_5;
                float2 _Combine_F763F954_RG_6;
                Unity_Combine_float(_Split_1A54F8B_R_1, _Split_FA827202_G_2, _Split_1A54F8B_B_3, 0, _Combine_F763F954_RGBA_4, _Combine_F763F954_RGB_5, _Combine_F763F954_RG_6);
                description.Position = _Combine_F763F954_RGB_5;
                return description;
            }

            struct SurfaceDescription
            {
                float3 Albedo;
                float3 Normal;
                float3 Emission;
                float Metallic;
                float Smoothness;
                float Occlusion;
                float Alpha;
                float AlphaClipThreshold;
            };

            SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
            {
                SurfaceDescription surface = (SurfaceDescription)0;
                float3 _Subtract_74F98413_Out_2;
                Unity_Subtract_float3(SHADERGRAPH_OBJECT_POSITION, _WorldSpaceCameraPos, _Subtract_74F98413_Out_2);
                float _Split_67329DB8_R_1 = _Subtract_74F98413_Out_2[0];
                float _Split_67329DB8_G_2 = _Subtract_74F98413_Out_2[1];
                float _Split_67329DB8_B_3 = _Subtract_74F98413_Out_2[2];
                float _Split_67329DB8_A_4 = 0;
                float4 _Combine_F209DAD0_RGBA_4;
                float3 _Combine_F209DAD0_RGB_5;
                float2 _Combine_F209DAD0_RG_6;
                Unity_Combine_float(_Split_67329DB8_R_1, 0, _Split_67329DB8_B_3, 0, _Combine_F209DAD0_RGBA_4, _Combine_F209DAD0_RGB_5, _Combine_F209DAD0_RG_6);
                float3 _Normalize_1F9A769D_Out_1;
                Unity_Normalize_float3(_Combine_F209DAD0_RGB_5, _Normalize_1F9A769D_Out_1);
                float3 _Transform_C904C633_Out_1 = TransformWorldToObjectDir(_Normalize_1F9A769D_Out_1.xyz);
                float _Split_ADCD8D4F_R_1 = _Transform_C904C633_Out_1[0];
                float _Split_ADCD8D4F_G_2 = _Transform_C904C633_Out_1[1];
                float _Split_ADCD8D4F_B_3 = _Transform_C904C633_Out_1[2];
                float _Split_ADCD8D4F_A_4 = 0;
                float _Arctangent2_4039E87E_Out_2;
                Unity_Arctangent2_float(_Split_ADCD8D4F_B_3, _Split_ADCD8D4F_R_1, _Arctangent2_4039E87E_Out_2);
                float _RadiansToDegrees_822E9378_Out_1;
                Unity_RadiansToDegrees_float(_Arctangent2_4039E87E_Out_2, _RadiansToDegrees_822E9378_Out_1);
                float _Add_F423FB93_Out_2;
                Unity_Add_float(_RadiansToDegrees_822E9378_Out_1, 0, _Add_F423FB93_Out_2);
                float _Add_B5DF3C81_Out_2;
                Unity_Add_float(_Add_F423FB93_Out_2, 90, _Add_B5DF3C81_Out_2);
                float _Modulo_E642AF79_Out_2;
                Unity_Modulo_float(_Add_B5DF3C81_Out_2, 360, _Modulo_E642AF79_Out_2);
                float _Subtract_420DDE08_Out_2;
                Unity_Subtract_float(360, _Modulo_E642AF79_Out_2, _Subtract_420DDE08_Out_2);
                float _Remap_859F7A9D_Out_3;
                Unity_Remap_float(_Subtract_420DDE08_Out_2, float2 (0, 360), float2 (0, 16), _Remap_859F7A9D_Out_3);
                float _Floor_AE29D009_Out_1;
                Unity_Floor_float(_Remap_859F7A9D_Out_3, _Floor_AE29D009_Out_1);
                float _Divide_EC99B270_Out_2;
                Unity_Divide_float(_Floor_AE29D009_Out_1, 4, _Divide_EC99B270_Out_2);
                float _Floor_BECE6315_Out_1;
                Unity_Floor_float(_Divide_EC99B270_Out_2, _Floor_BECE6315_Out_1);
                float _Divide_5696F1A6_Out_2;
                Unity_Divide_float(_Floor_BECE6315_Out_1, 4, _Divide_5696F1A6_Out_2);
                float _OneMinus_3DBE3279_Out_1;
                Unity_OneMinus_float(_Divide_5696F1A6_Out_2, _OneMinus_3DBE3279_Out_1);
                float _Multiply_D3C5014D_Out_2;
                Unity_Multiply_float(_Floor_BECE6315_Out_1, 4, _Multiply_D3C5014D_Out_2);
                float _Subtract_1796B96F_Out_2;
                Unity_Subtract_float(_Floor_AE29D009_Out_1, _Multiply_D3C5014D_Out_2, _Subtract_1796B96F_Out_2);
                float _Divide_F6C8A2F_Out_2;
                Unity_Divide_float(_Subtract_1796B96F_Out_2, 4, _Divide_F6C8A2F_Out_2);
                float2 _Vector2_7D220493_Out_0 = float2(_OneMinus_3DBE3279_Out_1, _Divide_F6C8A2F_Out_2);
                float4 _UV_76C93B5D_Out_0 = IN.uv0;
                float4 _Divide_9FCFC3DD_Out_2;
                Unity_Divide_float4(_UV_76C93B5D_Out_0, float4(4, 4, 4, 4), _Divide_9FCFC3DD_Out_2);
                float2 _Add_C3699259_Out_2;
                Unity_Add_float2(_Vector2_7D220493_Out_0, (_Divide_9FCFC3DD_Out_2.xy), _Add_C3699259_Out_2);
                float4 _SampleTexture2D_29A29D61_RGBA_0 = SAMPLE_TEXTURE2D(_Albedo, sampler_Albedo, _Add_C3699259_Out_2);
                float _SampleTexture2D_29A29D61_R_4 = _SampleTexture2D_29A29D61_RGBA_0.r;
                float _SampleTexture2D_29A29D61_G_5 = _SampleTexture2D_29A29D61_RGBA_0.g;
                float _SampleTexture2D_29A29D61_B_6 = _SampleTexture2D_29A29D61_RGBA_0.b;
                float _SampleTexture2D_29A29D61_A_7 = _SampleTexture2D_29A29D61_RGBA_0.a;
                float _Property_A51D11B2_Out_0 = _Hue;
                float3 _Hue_D09989EF_Out_2;
                Unity_Hue_Normalized_float((_SampleTexture2D_29A29D61_RGBA_0.xyz), _Property_A51D11B2_Out_0, _Hue_D09989EF_Out_2);
                float _Property_3C770CFC_Out_0 = _Saturation;
                float _Add_515FA5ED_Out_2;
                Unity_Add_float(_Property_3C770CFC_Out_0, 1, _Add_515FA5ED_Out_2);
                float3 _Saturation_843CD1F5_Out_2;
                Unity_Saturation_float(_Hue_D09989EF_Out_2, _Add_515FA5ED_Out_2, _Saturation_843CD1F5_Out_2);
                float _Property_93DBCFB9_Out_0 = _Lightness;
                float3 _Add_52C2111C_Out_2;
                Unity_Add_float3(_Saturation_843CD1F5_Out_2, (_Property_93DBCFB9_Out_0.xxx), _Add_52C2111C_Out_2);
                float4 _SampleTexture2D_E4B29158_RGBA_0 = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap, _Add_C3699259_Out_2);
                _SampleTexture2D_E4B29158_RGBA_0.rgb = UnpackNormalmapRGorAG(_SampleTexture2D_E4B29158_RGBA_0);
                float _SampleTexture2D_E4B29158_R_4 = _SampleTexture2D_E4B29158_RGBA_0.r;
                float _SampleTexture2D_E4B29158_G_5 = _SampleTexture2D_E4B29158_RGBA_0.g;
                float _SampleTexture2D_E4B29158_B_6 = _SampleTexture2D_E4B29158_RGBA_0.b;
                float _SampleTexture2D_E4B29158_A_7 = _SampleTexture2D_E4B29158_RGBA_0.a;
                float _Property_DA5F57E_Out_0 = _AlphaClipThreshold;
                surface.Albedo = _Add_52C2111C_Out_2;
                surface.Normal = (_SampleTexture2D_E4B29158_RGBA_0.xyz);
                surface.Emission = IsGammaSpace() ? float3(0, 0, 0) : SRGBToLinear(float3(0, 0, 0));
                surface.Metallic = 0;
                surface.Smoothness = 0.15;
                surface.Occlusion = 1;
                surface.Alpha = _SampleTexture2D_29A29D61_A_7;
                surface.AlphaClipThreshold = _Property_DA5F57E_Out_0;
                return surface;
            }

            struct GraphVertexInput
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 tangent : TANGENT;
                float4 texcoord0 : TEXCOORD0;
                float4 texcoord1 : TEXCOORD1;
                UNITY_VERTEX_INPUT_INSTANCE_ID
            };


        	struct GraphVertexOutput
            {
                float4 clipPos                : SV_POSITION;
        		// Interpolators defined by graph
                float3 WorldSpacePosition : TEXCOORD3;
                float3 WorldSpaceNormal : TEXCOORD4;
                float3 WorldSpaceTangent : TEXCOORD5;
                float3 WorldSpaceBiTangent : TEXCOORD6;
                float3 WorldSpaceViewDirection : TEXCOORD7;
                half4 uv0 : TEXCOORD8;
                half4 uv1 : TEXCOORD9;

            	UNITY_VERTEX_OUTPUT_STEREO
            };

            GraphVertexOutput vert (GraphVertexInput v)
        	{
        		GraphVertexOutput o = (GraphVertexOutput)0;
        		UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

        		// Vertex transformations performed by graph
                float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
                float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
                float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
                float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
                float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
                float4 uv0 = v.texcoord0;
                float4 uv1 = v.texcoord1;
                float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;

        		VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

        		// Vertex description inputs defined by graph
                vdi.WorldSpaceNormal = WorldSpaceNormal;
                vdi.WorldSpaceTangent = WorldSpaceTangent;
                vdi.WorldSpaceBiTangent = WorldSpaceBiTangent;
                vdi.ObjectSpacePosition = ObjectSpacePosition;

        	    VertexDescription vd = PopulateVertexData(vdi);
        		v.vertex.xyz = vd.Position;

        		// Vertex shader outputs defined by graph
                o.WorldSpacePosition = WorldSpacePosition;
                o.WorldSpaceNormal = WorldSpaceNormal;
                o.WorldSpaceTangent = WorldSpaceTangent;
                o.WorldSpaceBiTangent = WorldSpaceBiTangent;
                o.WorldSpaceViewDirection = WorldSpaceViewDirection;
                o.uv0 = uv0;
                o.uv1 = uv1;


                VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);
        	    o.clipPos = vertexInput.positionCS;

        		return o;
        	}

        	half4 frag (GraphVertexOutput IN ) : SV_Target
            {
        		UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);

        		// Pixel transformations performed by graph
                float3 WorldSpacePosition = IN.WorldSpacePosition;
                float3 WorldSpaceNormal = IN.WorldSpaceNormal;
                float3 WorldSpaceTangent = IN.WorldSpaceTangent;
                float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
                float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
                float4 uv0 = IN.uv0;
                float4 uv1 = IN.uv1;

                SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

        		// Surface description inputs defined by graph
                surfaceInput.WorldSpaceNormal = WorldSpaceNormal;
                surfaceInput.WorldSpaceTangent = WorldSpaceTangent;
                surfaceInput.WorldSpaceBiTangent = WorldSpaceBiTangent;
                surfaceInput.uv0 = uv0;

                SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

        		float3 Albedo = float3(0.5, 0.5, 0.5);
        		float3 Specular = float3(0, 0, 0);
        		float Metallic = 1;
        		float3 Normal = float3(0, 0, 1);
        		float3 Emission = 0;
        		float Smoothness = 0.5;
        		float Occlusion = 1;
        		float Alpha = 1;
        		float AlphaClipThreshold = 0;

        		// Surface description remap performed by graph
                Albedo = surf.Albedo;
                Normal = surf.Normal;
                Emission = surf.Emission;
                Metallic = surf.Metallic;
                Smoothness = surf.Smoothness;
                Occlusion = surf.Occlusion;
                Alpha = surf.Alpha;
                AlphaClipThreshold = surf.AlphaClipThreshold;


        		// Computes fog factor per-vertex
            	half4 color = half4(Albedo, Alpha);

        #if _AlphaClip
        		clip(Alpha - AlphaClipThreshold);
        #endif
        		return color;
            }

        	ENDHLSL
        }
    }
    CustomEditor "VisualDesignCafe.Nature.Editor.NatureMaterialEditor"
    FallBack "Hidden/InternalErrorShader"
}
